/**
 * Product Controller
 * Handles all product-related business logic
 */

const db = require('../config/database');
const redis = require('../config/redis');
const { AppError } = require('../utils/errors');

/**
 * Get all products with pagination and filters
 * @route GET /api/v1/products
 */
exports.getAllProducts = async (req, res, next) => {
  try {
    // Parse query parameters
    const page = parseInt(req.query.page) || 1;
    const limit = Math.min(parseInt(req.query.limit) || 20, 100); // Max 100 per page
    const offset = (page - 1) * limit;
    
    const {
      category,
      search,
      sort = 'created_at',
      order = 'DESC',
      minPrice,
      maxPrice,
      color,
      hasVideo,
      brand
    } = req.query;

    // Build WHERE clause
    let whereConditions = ['p.status = ?'];
    let queryParams = ['published'];

    if (category) {
      whereConditions.push('p.category_id = ?');
      queryParams.push(category);
    }

    if (search) {
      whereConditions.push('MATCH(p.title, p.description, p.meta_keywords) AGAINST (? IN NATURAL LANGUAGE MODE)');
      queryParams.push(search);
    }

    if (minPrice) {
      whereConditions.push('p.retail_price >= ?');
      queryParams.push(minPrice);
    }

    if (maxPrice) {
      whereConditions.push('p.retail_price <= ?');
      queryParams.push(maxPrice);
    }

    if (color) {
      whereConditions.push('p.color = ?');
      queryParams.push(color);
    }

    if (hasVideo === 'true') {
      whereConditions.push('p.video_url IS NOT NULL');
    }

    if (brand) {
      whereConditions.push('p.brand = ?');
      queryParams.push(brand);
    }

    const whereClause = whereConditions.join(' AND ');

    // Validate sort field
    const validSortFields = ['created_at', 'retail_price', 'title', 'import_count', 'rating_average'];
    const sortField = validSortFields.includes(sort) ? sort : 'created_at';
    const sortOrder = order.toUpperCase() === 'ASC' ? 'ASC' : 'DESC';

    // Get total count
    const [countResult] = await db.query(
      `SELECT COUNT(*) as total FROM products p WHERE ${whereClause}`,
      queryParams
    );
    const total = countResult[0].total;

    // Get products
    const query = `
      SELECT 
        p.id,
        p.sku,
        p.title,
        p.slug,
        p.short_description,
        p.cost_price,
        p.retail_price,
        p.sale_price,
        p.stock_status,
        p.brand,
        p.color,
        p.featured_image,
        p.video_url,
        p.rating_average,
        p.rating_count,
        p.import_count,
        c.name as category_name,
        c.slug as category_slug
      FROM products p
      LEFT JOIN categories c ON p.category_id = c.id
      WHERE ${whereClause}
      ORDER BY p.${sortField} ${sortOrder}
      LIMIT ? OFFSET ?
    `;

    const [products] = await db.query(query, [...queryParams, limit, offset]);

    // Calculate pagination metadata
    const totalPages = Math.ceil(total / limit);
    const hasNextPage = page < totalPages;
    const hasPrevPage = page > 1;

    // Track API usage
    await logApiUsage(req, 'get_all_products', products.length);

    res.json({
      success: true,
      data: products,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNextPage,
        hasPrevPage
      },
      filters: {
        category,
        search,
        minPrice,
        maxPrice,
        color,
        hasVideo,
        brand
      }
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Get single product by ID or SKU
 * @route GET /api/v1/products/:id
 */
exports.getProductById = async (req, res, next) => {
  try {
    const { id } = req.params;
    
    // Check if ID is numeric or SKU
    const isNumericId = /^\d+$/.test(id);
    const field = isNumericId ? 'p.id' : 'p.sku';

    const query = `
      SELECT 
        p.*,
        c.name as category_name,
        c.slug as category_slug,
        GROUP_CONCAT(DISTINCT t.name) as tags
      FROM products p
      LEFT JOIN categories c ON p.category_id = c.id
      LEFT JOIN product_tags pt ON p.id = pt.product_id
      LEFT JOIN tags t ON pt.tag_id = t.id
      WHERE ${field} = ? AND p.status = 'published'
      GROUP BY p.id
    `;

    const [products] = await db.query(query, [id]);

    if (products.length === 0) {
      throw new AppError('Product not found', 404);
    }

    const product = products[0];

    // Get product images
    const [images] = await db.query(
      `SELECT image_url, thumbnail_url, alt_text, sort_order, is_featured
       FROM product_images
       WHERE product_id = ?
       ORDER BY sort_order ASC`,
      [product.id]
    );

    product.images = images;

    // Get product variants
    const [variants] = await db.query(
      `SELECT id, sku, color, size, material, price_adjustment, 
              stock_quantity, stock_status, image_url
       FROM product_variants
       WHERE product_id = ? AND is_active = 1`,
      [product.id]
    );

    product.variants = variants;

    // Increment view count (async, don't wait)
    db.query(
      'UPDATE products SET view_count = view_count + 1 WHERE id = ?',
      [product.id]
    ).catch(err => console.error('Failed to increment view count:', err));

    // Update analytics (async)
    updateProductAnalytics(product.id, 'view').catch(err => 
      console.error('Failed to update analytics:', err)
    );

    res.json({
      success: true,
      data: product
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Get related products
 * @route GET /api/v1/products/:id/related
 */
exports.getRelatedProducts = async (req, res, next) => {
  try {
    const { id } = req.params;
    const limit = Math.min(parseInt(req.query.limit) || 5, 20);

    // Get the product's category
    const [sourceProduct] = await db.query(
      'SELECT category_id, brand FROM products WHERE id = ? AND status = "published"',
      [id]
    );

    if (sourceProduct.length === 0) {
      throw new AppError('Product not found', 404);
    }

    const { category_id, brand } = sourceProduct[0];

    // Find related products (same category or brand)
    const query = `
      SELECT 
        p.id,
        p.sku,
        p.title,
        p.slug,
        p.short_description,
        p.retail_price,
        p.sale_price,
        p.featured_image,
        p.rating_average,
        c.name as category_name
      FROM products p
      LEFT JOIN categories c ON p.category_id = c.id
      WHERE p.id != ? 
        AND p.status = 'published'
        AND (p.category_id = ? OR p.brand = ?)
      ORDER BY 
        CASE WHEN p.category_id = ? THEN 1 ELSE 2 END,
        p.import_count DESC,
        RAND()
      LIMIT ?
    `;

    const [relatedProducts] = await db.query(query, [
      id, 
      category_id, 
      brand, 
      category_id, 
      limit
    ]);

    res.json({
      success: true,
      data: relatedProducts
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Get product variants
 * @route GET /api/v1/products/:id/variants
 */
exports.getProductVariants = async (req, res, next) => {
  try {
    const { id } = req.params;

    const [variants] = await db.query(
      `SELECT 
        v.*,
        p.title as product_title
       FROM product_variants v
       JOIN products p ON v.product_id = p.id
       WHERE v.product_id = ? AND v.is_active = 1
       ORDER BY v.color, v.size`,
      [id]
    );

    res.json({
      success: true,
      data: variants
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Create new product (admin only)
 * @route POST /api/v1/products
 */
exports.createProduct = async (req, res, next) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin' && req.user.role !== 'super_admin') {
      throw new AppError('Unauthorized. Admin access required.', 403);
    }

    const productData = req.body;

    // Validate required fields
    const requiredFields = ['sku', 'title', 'cost_price', 'retail_price', 'category_id'];
    for (const field of requiredFields) {
      if (!productData[field]) {
        throw new AppError(`Missing required field: ${field}`, 400);
      }
    }

    // Check if SKU already exists
    const [existingSKU] = await db.query('SELECT id FROM products WHERE sku = ?', [productData.sku]);
    if (existingSKU.length > 0) {
      throw new AppError('Product with this SKU already exists', 409);
    }

    // Generate slug from title
    const slug = generateSlug(productData.title);

    // Insert product
    const [result] = await db.query(
      `INSERT INTO products (
        sku, category_id, title, slug, description, short_description,
        cost_price, retail_price, sale_price, stock_quantity, stock_status,
        weight, length, width, height, brand, manufacturer, material, color,
        meta_title, meta_description, meta_keywords,
        featured_image, video_url, has_360_view, status
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        productData.sku,
        productData.category_id,
        productData.title,
        slug,
        productData.description || null,
        productData.short_description || null,
        productData.cost_price,
        productData.retail_price,
        productData.sale_price || null,
        productData.stock_quantity || 0,
        productData.stock_status || 'in_stock',
        productData.weight || null,
        productData.length || null,
        productData.width || null,
        productData.height || null,
        productData.brand || null,
        productData.manufacturer || null,
        productData.material || null,
        productData.color || null,
        productData.meta_title || productData.title,
        productData.meta_description || null,
        productData.meta_keywords || null,
        productData.featured_image || null,
        productData.video_url || null,
        productData.has_360_view || 0,
        productData.status || 'draft'
      ]
    );

    const productId = result.insertId;

    // Insert product images if provided
    if (productData.images && productData.images.length > 0) {
      const imageValues = productData.images.map((img, index) => [
        productId,
        img.url,
        img.thumbnail || null,
        img.alt || productData.title,
        index,
        img.is_featured || 0
      ]);

      await db.query(
        `INSERT INTO product_images (product_id, image_url, thumbnail_url, alt_text, sort_order, is_featured)
         VALUES ?`,
        [imageValues]
      );
    }

    // Clear cache
    await redis.del('products:*');

    res.status(201).json({
      success: true,
      message: 'Product created successfully',
      data: {
        id: productId,
        sku: productData.sku,
        title: productData.title,
        slug
      }
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Update product (admin only)
 * @route PUT /api/v1/products/:id
 */
exports.updateProduct = async (req, res, next) => {
  try {
    if (req.user.role !== 'admin' && req.user.role !== 'super_admin') {
      throw new AppError('Unauthorized. Admin access required.', 403);
    }

    const { id } = req.params;
    const updateData = req.body;

    // Check if product exists
    const [existing] = await db.query('SELECT id FROM products WHERE id = ?', [id]);
    if (existing.length === 0) {
      throw new AppError('Product not found', 404);
    }

    // Build update query dynamically
    const allowedFields = [
      'title', 'description', 'short_description', 'cost_price', 'retail_price',
      'sale_price', 'stock_quantity', 'stock_status', 'category_id', 'brand',
      'color', 'weight', 'featured_image', 'video_url', 'status'
    ];

    const updates = [];
    const values = [];

    for (const [key, value] of Object.entries(updateData)) {
      if (allowedFields.includes(key)) {
        updates.push(`${key} = ?`);
        values.push(value);
      }
    }

    if (updates.length === 0) {
      throw new AppError('No valid fields to update', 400);
    }

    values.push(id);

    await db.query(
      `UPDATE products SET ${updates.join(', ')} WHERE id = ?`,
      values
    );

    // Clear cache
    await redis.del(`product:${id}`, 'products:*');

    res.json({
      success: true,
      message: 'Product updated successfully'
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Delete product (admin only)
 * @route DELETE /api/v1/products/:id
 */
exports.deleteProduct = async (req, res, next) => {
  try {
    if (req.user.role !== 'super_admin') {
      throw new AppError('Unauthorized. Super admin access required.', 403);
    }

    const { id } = req.params;

    const [result] = await db.query('DELETE FROM products WHERE id = ?', [id]);

    if (result.affectedRows === 0) {
      throw new AppError('Product not found', 404);
    }

    // Clear cache
    await redis.del(`product:${id}`, 'products:*');

    res.json({
      success: true,
      message: 'Product deleted successfully'
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Bulk create products (admin only)
 * @route POST /api/v1/products/bulk
 */
exports.bulkCreateProducts = async (req, res, next) => {
  try {
    if (req.user.role !== 'admin' && req.user.role !== 'super_admin') {
      throw new AppError('Unauthorized. Admin access required.', 403);
    }

    const { products } = req.body;

    if (!Array.isArray(products) || products.length === 0) {
      throw new AppError('Products array is required', 400);
    }

    if (products.length > 1000) {
      throw new AppError('Maximum 1000 products per bulk import', 400);
    }

    const results = {
      success: [],
      failed: []
    };

    for (const product of products) {
      try {
        const slug = generateSlug(product.title);
        
        const [result] = await db.query(
          `INSERT INTO products (sku, category_id, title, slug, cost_price, retail_price, status)
           VALUES (?, ?, ?, ?, ?, ?, ?)`,
          [
            product.sku,
            product.category_id,
            product.title,
            slug,
            product.cost_price,
            product.retail_price,
            'draft'
          ]
        );

        results.success.push({
          sku: product.sku,
          id: result.insertId
        });
      } catch (error) {
        results.failed.push({
          sku: product.sku,
          error: error.message
        });
      }
    }

    res.status(201).json({
      success: true,
      message: `Bulk import completed. ${results.success.length} succeeded, ${results.failed.length} failed.`,
      data: results
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Get search suggestions
 * @route GET /api/v1/products/search/suggestions
 */
exports.getSearchSuggestions = async (req, res, next) => {
  try {
    const { q, limit = 10 } = req.query;

    if (!q || q.length < 2) {
      return res.json({ success: true, data: [] });
    }

    const [suggestions] = await db.query(
      `SELECT DISTINCT title, slug
       FROM products
       WHERE title LIKE ? AND status = 'published'
       LIMIT ?`,
      [`%${q}%`, parseInt(limit)]
    );

    res.json({
      success: true,
      data: suggestions
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Get trending products
 * @route GET /api/v1/products/trending/top
 */
exports.getTrendingProducts = async (req, res, next) => {
  try {
    const limit = Math.min(parseInt(req.query.limit) || 20, 50);
    const period = req.query.period || 'week';

    // Calculate date range
    const daysAgo = period === 'day' ? 1 : period === 'week' ? 7 : 30;

    const [products] = await db.query(
      `SELECT 
        p.id, p.sku, p.title, p.slug, p.retail_price, p.featured_image,
        SUM(pa.import_count) as recent_imports,
        SUM(pa.view_count) as recent_views
       FROM products p
       LEFT JOIN product_analytics pa ON p.id = pa.product_id
       WHERE p.status = 'published'
         AND pa.date >= DATE_SUB(CURDATE(), INTERVAL ? DAY)
       GROUP BY p.id
       ORDER BY recent_imports DESC, recent_views DESC
       LIMIT ?`,
      [daysAgo, limit]
    );

    res.json({
      success: true,
      data: products,
      period
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Get product statistics (admin only)
 * @route GET /api/v1/products/stats/overview
 */
exports.getProductStats = async (req, res, next) => {
  try {
    if (req.user.role !== 'admin' && req.user.role !== 'super_admin') {
      throw new AppError('Unauthorized. Admin access required.', 403);
    }

    const [stats] = await db.query(`
      SELECT 
        COUNT(*) as total_products,
        COUNT(CASE WHEN status = 'published' THEN 1 END) as published_products,
        COUNT(CASE WHEN stock_status = 'out_of_stock' THEN 1 END) as out_of_stock_products,
        AVG(retail_price) as avg_price,
        SUM(import_count) as total_imports,
        SUM(view_count) as total_views
      FROM products
    `);

    const [categoryStats] = await db.query(`
      SELECT 
        c.name,
        COUNT(p.id) as product_count
      FROM categories c
      LEFT JOIN products p ON c.id = p.category_id
      GROUP BY c.id
      ORDER BY product_count DESC
      LIMIT 10
    `);

    res.json({
      success: true,
      data: {
        overview: stats[0],
        topCategories: categoryStats
      }
    });
  } catch (error) {
    next(error);
  }
};

// ==========================================
// Helper Functions
// ==========================================

/**
 * Generate URL-friendly slug
 */
function generateSlug(title) {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

/**
 * Log API usage
 */
async function logApiUsage(req, endpoint, resultCount) {
  try {
    await db.query(
      `INSERT INTO api_logs (user_id, endpoint, method, status_code, ip_address)
       VALUES (?, ?, ?, ?, ?)`,
      [req.user?.id || null, endpoint, req.method, 200, req.ip]
    );
  } catch (error) {
    console.error('Failed to log API usage:', error);
  }
}

/**
 * Update product analytics
 */
async function updateProductAnalytics(productId, action) {
  const today = new Date().toISOString().split('T')[0];
  const field = action === 'view' ? 'view_count' : 'import_count';

  await db.query(
    `INSERT INTO product_analytics (product_id, date, ${field})
     VALUES (?, ?, 1)
     ON DUPLICATE KEY UPDATE ${field} = ${field} + 1`,
    [productId, today]
  );
}
